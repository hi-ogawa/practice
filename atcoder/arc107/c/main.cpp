// CONTEST, AC

#include <bits/stdc++.h>
using namespace std;

#define ALL(X) (X).begin(), (X).end()
#define FOR(I, X, Y) for (auto I = decltype(Y)(X); I < (Y); ++I)
using ll = int64_t;
using ull = uint64_t;
namespace std {
template<class ...Ts>        istream& operator>>(istream& i,       tuple<Ts...>& x) { apply([&](auto&&... ys){ ((i >> ys), ...); }, x); return i; }
template<class ...Ts>        ostream& operator<<(ostream& o, const tuple<Ts...>& x) { o << "("; auto s = ""; apply([&](auto&&... y){ ((o << s << y, s = ", "), ...); }, x); return o << ")"; }
template<class T1, class T2> istream& operator>>(istream& i,       pair<T1, T2>& x) { return i >> tie(x.first, x.second); }
template<class T1, class T2> ostream& operator<<(ostream& o, const pair<T1, T2>& x) { return o << tie(x.first, x.second); }
template<class T, class = decltype(begin(declval<T>())), class = enable_if_t<!is_same<T, string>::value>>
istream& operator>>(istream& i,       T& x) { for (auto& y : x) { i >> y; } return i; }
template<class T, class = decltype(begin(declval<T>())), class = enable_if_t<!is_same<T, string>::value>>
ostream& operator<<(ostream& o, const T& x) { o << "{"; auto s = ""; for (auto& y : x) { o << s << y; s = ", "; } return o << "}"; }
}

#ifdef DEBUG
#define dbg(...) do { cout << #__VA_ARGS__ ": " << make_tuple(__VA_ARGS__) << endl; } while (0)
#define dbg2(X) do { cout << #X ":\n"; for (auto& __x : (X)) { cout << __x << endl; } } while (0)
#else
#define dbg(...)
#define dbg2(X)
#endif


// Modulo integer
template<ll Modulo>
struct ModInt {
  using mint = ModInt;
  static constexpr ll modulo = Modulo;
  uint32_t v;
  ModInt() : v{0} {}
  template<class T, class = enable_if_t<is_integral_v<T>>>
  ModInt(T x) { ll y = (ll)x % modulo; if (y < 0) { y += modulo; } v = y; }
  friend istream& operator>>(istream& istr,       mint& self) { return istr >> self.v; }
  friend ostream& operator<<(ostream& ostr, const mint& self) { return ostr << self.v; }
  mint& operator+=(const mint& y) { v += y.v; while (v >= modulo) { v -= modulo; }; return *this; }
  mint& operator-=(const mint& y) { return *this += (modulo - y.v); }
  mint& operator*=(const mint& y) { v = (ll)v * y.v % modulo; return *this; }
  mint& operator/=(const mint& y) { return *this *= y.inv(); }
  friend mint operator+(const mint& x, const mint& y) { return mint(x) += y; }
  friend mint operator-(const mint& x, const mint& y) { return mint(x) -= y; }
  friend mint operator*(const mint& x, const mint& y) { return mint(x) *= y; }
  friend mint operator/(const mint& x, const mint& y) { return mint(x) /= y; }
  friend bool operator==(const mint& x, const mint& y) { return x.v == y.v; }
  friend bool operator!=(const mint& x, const mint& y) { return x.v != y.v; }
  mint operator-() const { return mint() - *this; }
  mint inv() const { return pow(modulo - 2); }
  mint pow(ll e) const {
    mint x = *this, res = 1;
    while (e > 0) {
      if (e & 1) { res *= x; }
      e >>= 1; x *= x;
    }
    return res;
  }

  // Factorial, binomial
  static inline vector<mint> fact;
  static void makeFactorials(int n) {
    fact.assign(n + 1, 1);
    for (int i = 2; i <= n; i++) {
      fact[i] = fact[i - 1] * i;
    }
  }
};

using mint = ModInt<998244353>;

// DSU
struct Dsu {
  vector<int> ps;
  Dsu(int n) { ps.resize(n); iota(ALL(ps), 0); }
  int find(int a) {
    if (a == ps[a]) { return a; }
    return ps[a] = find(ps[a]);
  }
  void merge(int dst, int src) {
    ps[find(src)] = find(dst);
  }
};

// Main
void mainCase() {
  int n, k; // n \in [1, 50], k \in [1, 2 x n^2]
  cin >> n >> k;
  vector<vector<int>> ls(n, vector<int>(n)); // {1, 2, .., n^2}
  cin >> ls;

  // Precompute factorial
  mint::makeFactorials(n);

  // Subgroup of Sn generated by row swap
  Dsu dsu1(n);
  FOR(i1, 0, n) {
    FOR(i2, 0, n) {
      bool ok = 1;
      FOR(j, 0, n) {
        if (ls[i1][j] + ls[i2][j] > k) {
          ok = 0;
          break;
        }
      }
      if (ok) {
        dsu1.merge(i1, i2);
      }
    }
  }
  map<int, int> cnts1;
  FOR(i, 0, n) {
    cnts1[dsu1.find(i)]++;
  }
  mint res1 = 1;
  for (auto [k, v] : cnts1) {
    res1 *= mint::fact[v];
  }

  // Do the same for column swap
  Dsu dsu2(n);
  FOR(j1, 0, n) {
    FOR(j2, 0, n) {
      bool ok = 1;
      FOR(i, 0, n) {
        if (ls[i][j1] + ls[i][j2] > k) {
          ok = 0;
          break;
        }
      }
      if (ok) {
        dsu2.merge(j1, j2);
      }
    }
  }
  map<int, int> cnts2;
  FOR(j, 0, n) {
    cnts2[dsu2.find(j)]++;
  }
  mint res2 = 1;
  for (auto [k, v] : cnts2) {
    res2 *= mint::fact[v];
  }

  // Answer is the product group of two subgroups
  mint res = res1 * res2;
  dbg(res1, res2, res);
  cout << res << "\n";
}

int main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  mainCase();
  return 0;
}

/*
python misc/run.py atcoder/arc107/c/main.cpp

%%%% begin
3 13
3 2 7
4 8 9
1 6 5
%%%%
12
%%%% end

%%%% begin
10 165
82 94 21 65 28 22 61 80 81 79
93 35 59 85 96 1 78 72 43 5
12 15 97 49 69 53 18 73 6 58
60 14 23 19 44 99 64 17 29 67
24 39 56 92 88 7 48 75 36 91
74 16 26 10 40 63 45 76 86 3
9 66 42 84 38 51 25 2 33 41
87 54 57 62 47 31 68 11 83 8
46 27 55 70 52 98 20 77 89 34
32 71 30 50 90 4 37 95 13 100
%%%%
348179577
%%%% end
*/
